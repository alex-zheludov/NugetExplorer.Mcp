using System.Net.Http.Json;
using System.Text.Json;
using Microsoft.Extensions.Logging;
using NuGetExplorerMcp.Application.Interfaces;
using NuGetExplorerMcp.Domain.Entities;
using NuGetExplorerMcp.Domain.Enums;
using NuGetExplorerMcp.Domain.ValueObjects;

namespace NuGetExplorerMcp.Infrastructure.Services;

/// <summary>
/// Scans packages for known security vulnerabilities using GitHub Advisory Database.
/// Follows Dependency Inversion Principle (DIP) by depending on abstractions (ICacheService).
/// </summary>
public class VulnerabilityScanner : IVulnerabilityScanner
{
    private readonly ILogger<VulnerabilityScanner> _logger;
    private readonly ICacheService _cacheService;
    private readonly HttpClient _httpClient;

    public VulnerabilityScanner(
        ILogger<VulnerabilityScanner> logger,
        ICacheService cacheService,
        HttpClient httpClient)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _cacheService = cacheService ?? throw new ArgumentNullException(nameof(cacheService));
        _httpClient = httpClient ?? throw new ArgumentNullException(nameof(httpClient));

        // Configure HttpClient for GitHub API
        if (!_httpClient.DefaultRequestHeaders.Contains("User-Agent"))
        {
            _httpClient.DefaultRequestHeaders.Add("User-Agent", "NuGetExplorerMcp");
        }
    }

    public async Task<IReadOnlyList<Vulnerability>> GetVulnerabilitiesAsync(
        PackageReference package,
        CancellationToken cancellationToken = default)
    {
        var cacheKey = $"vuln:{package.Id}:{package.Version}";

        return await _cacheService.GetOrSetAsync(
            cacheKey,
            async ct =>
            {
                var vulnerabilities = new List<Vulnerability>();

                try
                {
                    // Query GitHub Advisory Database
                    var githubVulns = await QueryGitHubAdvisoryDatabaseAsync(package, ct);
                    vulnerabilities.AddRange(githubVulns);
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex, "Failed to query GitHub Advisory Database for {PackageId}",
                        package.Id);
                }

                return vulnerabilities as IReadOnlyList<Vulnerability>;
            },
            TimeSpan.FromHours(6),
            cancellationToken);
    }

    private async Task<List<Vulnerability>> QueryGitHubAdvisoryDatabaseAsync(
        PackageReference package,
        CancellationToken cancellationToken)
    {
        var vulnerabilities = new List<Vulnerability>();

        try
        {
            // GitHub Advisory Database API endpoint
            var url = $"https://api.github.com/advisories?ecosystem=nuget&package={Uri.EscapeDataString(package.Id)}";

            var response = await _httpClient.GetAsync(url, cancellationToken);

            if (!response.IsSuccessStatusCode)
            {
                _logger.LogWarning("GitHub Advisory API returned {StatusCode} for {PackageId}",
                    response.StatusCode, package.Id);
                return vulnerabilities;
            }

            var advisories = await response.Content.ReadFromJsonAsync<List<GitHubAdvisory>>(cancellationToken);

            if (advisories == null)
                return vulnerabilities;

            foreach (var advisory in advisories)
            {
                // Check if the current package version is affected
                if (IsVersionAffected(package.Version, advisory))
                {
                    vulnerabilities.Add(new Vulnerability
                    {
                        Id = advisory.GhsaId,
                        Cve = advisory.CveId,
                        Severity = MapSeverity(advisory.Severity),
                        Description = advisory.Summary ?? "No description available",
                        AffectedVersions = FormatAffectedVersions(advisory),
                        PatchedVersion = GetPatchedVersion(advisory),
                        PublishedDate = advisory.PublishedAt,
                        AdvisoryUrl = advisory.HtmlUrl ?? $"https://github.com/advisories/{advisory.GhsaId}"
                    });
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error querying GitHub Advisory Database for {PackageId}", package.Id);
        }

        return vulnerabilities;
    }

    private bool IsVersionAffected(string version, GitHubAdvisory advisory)
    {
        // Simplified check for now.
        // TODO: Parse affected version ranges from the advisory payload and evaluate the current version against them.
        return true;
    }

    private SeverityLevel MapSeverity(string? severity)
    {
        return severity?.ToLowerInvariant() switch
        {
            "critical" => SeverityLevel.Critical,
            "high" => SeverityLevel.High,
            "medium" => SeverityLevel.Medium,
            "low" => SeverityLevel.Low,
            _ => SeverityLevel.Medium
        };
    }

    private string FormatAffectedVersions(GitHubAdvisory advisory)
    {
        // Simplified - would parse vulnerabilities array in full implementation
        return "< patched version";
    }

    private string? GetPatchedVersion(GitHubAdvisory advisory)
    {
        // Would extract from vulnerabilities array in full implementation
        return null;
    }

    // DTOs for GitHub Advisory API
    private class GitHubAdvisory
    {
        public string GhsaId { get; set; } = string.Empty;
        public string? CveId { get; set; }
        public string? Summary { get; set; }
        public string? Severity { get; set; }
        public DateTime? PublishedAt { get; set; }
        public string? HtmlUrl { get; set; }
    }
}
